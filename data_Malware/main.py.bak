import pefile
import os
import hashlib
from entropy import get_entropy
from getResources import get_resources
from getVersionInfo import get_version_info
from packer import *

def get_md5(fname):
    hash_md5 = hashlib.md5()
    with open(fname, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hash_md5.update(chunk)
    return hash_md5.hexdigest()

def sha256(fname):
	#filename = input("Enter the input file name: ")
	f = open(fname, "rb")
	byte = f.read()
	readable_hash = hashlib.sha256(byte).hexdigest();   
	return readable_hash

def get_file_info(file_path):
	save_file = "data.csv"

	fFile = open(save_file, mode="a")

	delimiter = "|"
	delimiter_for_list = ", "

	#file_path = "testFolder_safe/libobs-opengl.dll"

	fileHeader = []

	try:
		#fileName
		#pe = pefile.PE(file_path)
		fileHeader.append(os.path.basename(file_path))

		#MD5
		fileHeader.append(md5(file_path))

		#SHA256
		fileHeader.append(sha256(file_path))

		#Create PE
		pe = pefile.PE(file_path)
		#for entryDLL in pe.DIRECTORY_ENTRY_IMPORT:
		#	print("\n" + entryDLL.dll.decode("utf-8"))

		#FILE_HEADER: 4
		fileHeader.append(pe.FILE_HEADER.Machine)
		fileHeader.append(pe.FILE_HEADER.NumberOfSections)
		fileHeader.append(pe.FILE_HEADER.NumberOfSymbols)
		fileHeader.append(pe.FILE_HEADER.Characteristics)

		#OPTIONAL_HEADER: 16
		fileHeader.append(pe.OPTIONAL_HEADER.SizeOfCode)
		fileHeader.append(pe.OPTIONAL_HEADER.AddressOfEntryPoint)
		fileHeader.append(pe.OPTIONAL_HEADER.MajorImageVersion)
		fileHeader.append(pe.OPTIONAL_HEADER.MinorImageVersion)
		fileHeader.append(pe.OPTIONAL_HEADER.MajorSubsystemVersion)
		fileHeader.append(pe.OPTIONAL_HEADER.MinorSubsystemVersion)
		fileHeader.append(pe.OPTIONAL_HEADER.SizeOfImage)
		fileHeader.append(pe.OPTIONAL_HEADER.CheckSum)
		fileHeader.append(pe.OPTIONAL_HEADER.Subsystem)
		fileHeader.append(pe.OPTIONAL_HEADER.DllCharacteristics)
		fileHeader.append(pe.OPTIONAL_HEADER.SizeOfStackReserve)
		fileHeader.append(pe.OPTIONAL_HEADER.SizeOfStackCommit)
		fileHeader.append(pe.OPTIONAL_HEADER.SizeOfHeapReserve)
		fileHeader.append(pe.OPTIONAL_HEADER.SizeOfHeapCommit)
		fileHeader.append(pe.OPTIONAL_HEADER.LoaderFlags)
		fileHeader.append(pe.OPTIONAL_HEADER.NumberOfRvaAndSizes)
		fileHeader.append(len(pe.sections)) #sections number
		
		#get_entropy
		entropy = [x.get_entropy() for x in pe.sections]

		fileHeader.append(sum(entropy) / float(len((entropy)))) #SectionsMeanEntropy
		fileHeader.append(min(entropy)) #SectionsMinEntropy
		fileHeader.append(max(entropy)) #SectionsMaxEntropy

		#Rawsize
		raw_sizes = [x.SizeOfRawData for x in pe.sections]
		fileHeader.append(sum(raw_sizes) / float(len(raw_sizes))) #SectionsMeanRawsize
		fileHeader.append(min(raw_sizes)) #SectionsMinRawsize
		fileHeader.append(max(raw_sizes)) #SectionMaxRawsize

		virtual_sizes = [x.Misc_VirtualSize for x in pe.sections]
		fileHeader.append(sum(virtual_sizes) / float(len(virtual_sizes))) #SectionsMeanVirtualsize
		fileHeader.append(min(virtual_sizes)) #SectionsMinVirtualsize
		fileHeader.append(max(virtual_sizes)) #SectionMaxVirtualsize




		fileDll = []
		for entryDLL in pe.DIRECTORY_ENTRY_IMPORT:
			fileDll.append(entryDLL.dll.decode("utf-8"))



		typeOfFIle = "Unknown"
		
		for i in fileDll:
			if("Unity" in i):
				typeOfFIle = "Game engine"
			elif ("Crypt" in i):
				typeOfFIle = "Encrypter"
			elif ("OPENGL" in i):
				typeOfFIle = "Graphic engine"



		#PE_Section
		#fileHeader.append(pe.IMAGE_SECTION_HEADER.VirtualAddress)
		#fileHeader.append(pe.IMAGE_SECTION_HEADER.SizeOfRawData)
		#fileHeader.append(pe.IMAGE_SECTION_HEADER.Flags)

		fFile.write(delimiter.join([str(i) for i in fileHeader]))
		fFile.write(delimiter)
		fFile.write(delimiter_for_list.join([str(i) for i in fileDll]))
		fFile.write(delimiter)
		fFile.write(str(typeOfFIle))
		#fFile.write("\n")

		
		print("Phân tích thành công file " + os.path.basename(file_path))

	except pefile.PEFormatError:
		print("File " + os.path.basename((file_path)) +  " không phải định dạng PE")
		return 0
	except:
		print("Phân tích file " + os.path.basename(file_path) + " thất bại do có exception.")
		return 0

	fFile.close()
	return 1

def main():
	
	delimiter = "|"
	delimiter_for_list = ", "

	colums = [
	"Name",
	"MD5",
	"SHA256",

	#FILE_HEADER: 4
	"Machine",
	"SizeofOptionalHeader", #
	"MajorLinkerVersion",   #
	"MinorLinkerVersion",   #
	"NumberOfSections",
	"NumberOfSymbols",
	"Characteristics",

	#OPTIONAL_HEADER: 16
	"SizeOfCode",
	"SizeOfInitializedData",    #
    "SizeOfUninitializedData",  #
	

	"AddressOfEntryPoint",
 	

 	"BaseOfCode",					#
    "BaseOfData",					#
    "ImageBase",					#
    "SectionAlignment",				#
    "FileAlignment",				#
    "MajorOperatingSystemVersion",	#
    "MinorOperatingSystemVersion",	#

	
	"MajorImageVersion",
	"MinorImageVersion",
	"MajorSubsystemVersion",
	"MinorSubsystemVersion",
	"SizeOfImage",
	"CheckSum",
	"Subsystem",
	"DllCharacteristics",
	"SizeOfStackReserve",
	"SizeOfStackCommit",
	"SizeOfHeapReserve",
	"SizeOfHeapCommit",
	"LoaderFlags",
	"NumberOfRvaAndSizes",
	
	#Entropy
	"SectionsNb",
    "SectionsMeanEntropy",
    "SectionsMinEntropy",
    "SectionsMaxEntropy",

    "SectionsMeanRawsize",
    "SectionsMinRawsize",
    "SectionMaxRawsize",

    "SectionsMeanVirtualsize",
	"SectionsMinVirtualsize",
    "SectionMaxVirtualsize",

    "ImportsNbDLL",					#
    "ImportsNb",					#
    "ImportsNbOrdinal",				#
    "ExportNb",						#
    "ResourcesNb",					#
    "ResourcesMeanEntropy",			#
    "ResourcesMinEntropy",			#
    "ResourcesMaxEntropy",			#
    "ResourcesMeanSize",			#
    "ResourcesMinSize",				#	
    "ResourcesMaxSize",				#
    "LoadConfigurationSize",		#
    "VersionInformationSize",		#

	#DLL use
	"DLL",

	#Type of file
	"Type",

	"Path"

	]

	path = ""

	save_file = "data.csv"

	try:
		fFile = open(save_file, "w")
		fFile.write(delimiter.join(colums) + "\n")
	except:
		print("Không thể mở file")

	fFile.close()


	for file_name in os.listdir("testFolder_safe"):
		if(get_file_info(os.path.join("testFolder_safe/", file_name))):
			f = open(save_file, "a")
			f.write(delimiter)
			f.write(str(1)) #safe

			f.write("\n")
			f.close()
	

	for file in os.listdir("testFolder_unsafe"):
		if(get_file_info(os.path.join("testFolder_unsafe", file))):
			f = open(save_file, "a")
			f.write(delimiter)
			f.write(str(0)) #unsafe

			f.write("\n")
			f.close()

def scanFolder(folder_path):
	for filename in os.listdir(folder_path):
		if(os.path.isdir(os.path.join(folder_path, filename))):
			scanFolder(os.path.join(folder_path, filename))
		else:
			get_file(os.path.join(folder_path, filename))


'''
def createRawCSV():
	delimiter = "|"
	delimiter_for_list = ", "

	colums = [ #62 truong
	"Name",
	"MD5",
	#"SHA256",

	#FILE_HEADER: 4
	"Machine",
	"SizeofOptionalHeader", #
	"MajorLinkerVersion",   #
	"MinorLinkerVersion",   #
	"NumberOfSections",
	"NumberOfSymbols",
	"Characteristics",

	#OPTIONAL_HEADER: 16
	"SizeOfCode",
	"SizeOfInitializedData",    #
    "SizeOfUninitializedData",  #
	
	"AddressOfEntryPoint",
 	"BaseOfCode",					#
    "BaseOfData",					#
    "ImageBase",					#
    "SectionAlignment",				#
    "FileAlignment",				#
    "MajorOperatingSystemVersion",	#
    "MinorOperatingSystemVersion",	#
	
	"MajorImageVersion",
	"MinorImageVersion",
	"MajorSubsystemVersion",
	"MinorSubsystemVersion",
	"SizeOfImage",
	"CheckSum",
	"Subsystem",
	"DllCharacteristics",
	"SizeOfStackReserve",
	"SizeOfStackCommit",
	"SizeOfHeapReserve",
	"SizeOfHeapCommit",
	"LoaderFlags",
	"NumberOfRvaAndSizes",
	
	#Entropy
	"SectionsNb",
    "SectionsMeanEntropy",
    "SectionsMinEntropy",
    "SectionsMaxEntropy",
    "SectionsMeanRawsize",
    "SectionsMinRawsize",
    "SectionMaxRawsize",
    "SectionsMeanVirtualsize",
	"SectionsMinVirtualsize",
    "SectionMaxVirtualsize",
    "ImportsNbDLL",					#
    "ImportsNb",					#
    "ImportsNbOrdinal",				#
    "ExportNb",						#
    "ResourcesNb",					#
    "ResourcesMeanEntropy",			#
    "ResourcesMinEntropy",			#
    "ResourcesMaxEntropy",			#
    "ResourcesMeanSize",			#
    "ResourcesMinSize",				#	
    "ResourcesMaxSize",				#
    "LoadConfigurationSize",		#
    "VersionInformationSize",		#

	#DLL use
	"DLL",

	#Type of file
	"Type",

	"Path",

	"Pack",

	"Safe",

	"Label"

	]

	path = ""

	save_file = "data.csv"

	try:
		fFile = open(save_file, "w")
		fFile.write(delimiter.join(colums) + "\n")
	except:
		fFile.close()
		print("Không thể mở file")

	fFile.close()
'''


def createRawCSV():
	delimiter = "|"

	columns = [
        "Name",
        "md5",
        "Machine",
        "SizeOfOptionalHeader",
        "Characteristics",
        "MajorLinkerVersion",
        "MinorLinkerVersion",
        "SizeOfCode",
        "SizeOfInitializedData",
        "SizeOfUninitializedData",
        "AddressOfEntryPoint",
        "BaseOfCode",
        "BaseOfData",
        "ImageBase",
        "SectionAlignment",
        "FileAlignment",
        "MajorOperatingSystemVersion",
        "MinorOperatingSystemVersion",
        "MajorImageVersion",
        "MinorImageVersion",
        "MajorSubsystemVersion",
        "MinorSubsystemVersion",
        "SizeOfImage",
        "SizeOfHeaders",
        "CheckSum",
        "Subsystem",
        "DllCharacteristics",
        "SizeOfStackReserve",
        "SizeOfStackCommit",
        "SizeOfHeapReserve",
        "SizeOfHeapCommit",
        "LoaderFlags",
        "NumberOfRvaAndSizes",
        "SectionsNb",
        "SectionsMeanEntropy",
        "SectionsMinEntropy",
        "SectionsMaxEntropy",
        "SectionsMeanRawsize",
        "SectionsMinRawsize",
        "SectionMaxRawsize",
        "SectionsMeanVirtualsize",
        "SectionsMinVirtualsize",
        "SectionMaxVirtualsize",
        "ImportsNbDLL",
        "ImportsNb",
        "ImportsNbOrdinal",
        "ExportNb",
        "ResourcesNb",
        "ResourcesMeanEntropy",
        "ResourcesMinEntropy",
        "ResourcesMaxEntropy",
        "ResourcesMeanSize",
        "ResourcesMinSize",
        "ResourcesMaxSize",
        "LoadConfigurationSize",
        "VersionInformationSize",
        "legitimate"
    ]


	path = ""

	save_file = "data.csv"

	try:
		fFile = open(save_file, "w")
		fFile.write(delimiter.join(colums) + "\n")
	except:
		fFile.close()
		print("Không thể mở file")

	fFile.close()


def get_file(file_path):
	print(file_path)
	save_file = "data.csv"

	fFile = open(save_file, mode="a")

	delimiter = "|"

	try:
		res = []
		res.append(os.path.basename(file_path))
		res.append(get_md5(file_path))
		pe = pefile.PE(file_path)
		res.append(pe.FILE_HEADER.Machine)
		res.append(pe.FILE_HEADER.SizeOfOptionalHeader)
		res.append(pe.FILE_HEADER.Characteristics)
		res.append(pe.OPTIONAL_HEADER.MajorLinkerVersion)
		res.append(pe.OPTIONAL_HEADER.MinorLinkerVersion)
		res.append(pe.OPTIONAL_HEADER.SizeOfCode)
		res.append(pe.OPTIONAL_HEADER.SizeOfInitializedData)
		res.append(pe.OPTIONAL_HEADER.SizeOfUninitializedData)
		res.append(pe.OPTIONAL_HEADER.AddressOfEntryPoint)
		res.append(pe.OPTIONAL_HEADER.BaseOfCode)
		try:
			res.append(pe.OPTIONAL_HEADER.BaseOfData)
		except AttributeError:
			res.append(0)
		res.append(pe.OPTIONAL_HEADER.ImageBase)
		res.append(pe.OPTIONAL_HEADER.SectionAlignment)
		res.append(pe.OPTIONAL_HEADER.FileAlignment)
		res.append(pe.OPTIONAL_HEADER.MajorOperatingSystemVersion)
		res.append(pe.OPTIONAL_HEADER.MinorOperatingSystemVersion)
		res.append(pe.OPTIONAL_HEADER.MajorImageVersion)
		res.append(pe.OPTIONAL_HEADER.MinorImageVersion)
		res.append(pe.OPTIONAL_HEADER.MajorSubsystemVersion)
		res.append(pe.OPTIONAL_HEADER.MinorSubsystemVersion)
		res.append(pe.OPTIONAL_HEADER.SizeOfImage)
		res.append(pe.OPTIONAL_HEADER.SizeOfHeaders)
		res.append(pe.OPTIONAL_HEADER.CheckSum)
		res.append(pe.OPTIONAL_HEADER.Subsystem)
		res.append(pe.OPTIONAL_HEADER.DllCharacteristics)
		res.append(pe.OPTIONAL_HEADER.SizeOfStackReserve)
		res.append(pe.OPTIONAL_HEADER.SizeOfStackCommit)
		res.append(pe.OPTIONAL_HEADER.SizeOfHeapReserve)
		res.append(pe.OPTIONAL_HEADER.SizeOfHeapCommit)
		res.append(pe.OPTIONAL_HEADER.LoaderFlags)
		res.append(pe.OPTIONAL_HEADER.NumberOfRvaAndSizes)
		res.append(len(pe.sections))
		entropy = map(lambda x: x.get_entropy(), pe.sections)
		res.append(sum(entropy) / float(len(entropy)))
		res.append(min(entropy))
		res.append(max(entropy))
		raw_sizes = map(lambda x: x.SizeOfRawData, pe.sections)
		res.append(sum(raw_sizes) / float(len(raw_sizes)))
		res.append(min(raw_sizes))
		res.append(max(raw_sizes))
		virtual_sizes = map(lambda x: x.Misc_VirtualSize, pe.sections)
		res.append(sum(virtual_sizes) / float(len(virtual_sizes)))
		res.append(min(virtual_sizes))
		res.append(max(virtual_sizes))
	    # Imports
		try:
			res.append(len(pe.DIRECTORY_ENTRY_IMPORT))
			imports = sum([x.imports for x in pe.DIRECTORY_ENTRY_IMPORT], [])
			res.append(len(imports))
			res.append(len(filter(lambda x: x.name is None, imports)))
		except AttributeError:
			res.append(0)
			res.append(0)
			res.append(0)
	    # Exports
		try:
			res.append(len(pe.DIRECTORY_ENTRY_EXPORT.symbols))
		except AttributeError:
	        # No export
			res.append(0)
	    # Resources
		resources = get_resources(pe)
		res.append(len(resources))
		if len(resources) > 0:
			entropy = map(lambda x: x[0], resources)
			res.append(sum(entropy) / float(len(entropy)))
			res.append(min(entropy))
			res.append(max(entropy))
			sizes = map(lambda x: x[1], resources)
			res.append(sum(sizes) / float(len(sizes)))
			res.append(min(sizes))
			res.append(max(sizes))
		else:
			res.append(0)
			res.append(0)
			res.append(0)
			res.append(0)
			res.append(0)
			res.append(0)

	    # Load configuration size
		try:
			res.append(pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.Size)
		except AttributeError:
			res.append(0)

		# Version configuration size
		try:
			version_infos = get_version_info(pe)
			res.append(len(version_infos.keys()))
		except AttributeError:
			res.append(0)


		fFile.write(delimiter.join([str(i) for i in fileHeader]))

		if("VIRUS" in file_path):

			fFile.write("0")
		else:
			fFile.write("1")

		fFile.write("\n")

	except pefile.PEFormatError:
		print("File " + os.path.basename((file_path)) +  " không phải định dạng PE")
		fFile.close()
		return 
	except Exception as e:
		print("Phân tích file " + os.path.basename(file_path) + " thất bại do có exception.")
		
		print(e)
		fFile.close()
		return 

	fFile.close()
	return 


'''
def get_file(file_path):
	print(file_path)
	save_file = "data.csv"

	fFile = open(save_file, mode="a")

	delimiter = "|"
	delimiter_for_list = ", "

	#file_path = "testFolder_safe/libobs-opengl.dll"

	fileHeader = []

	try:
		#fileName
		#pe = pefile.PE(file_path)
		fileHeader.append(os.path.basename(file_path))

		#MD5
		fileHeader.append(md5(file_path))

		#SHA256
		#fileHeader.append(sha256(file_path))

		#Create PE
		pe = pefile.PE(file_path)
		#for entryDLL in pe.DIRECTORY_ENTRY_IMPORT:
		#	print("\n" + entryDLL.dll.decode("utf-8"))

		#FILE_HEADER: 7
		fileHeader.append(pe.FILE_HEADER.Machine)
		fileHeader.append(pe.FILE_HEADER.SizeOfOptionalHeader)
		fileHeader.append(pe.OPTIONAL_HEADER.MajorLinkerVersion)
		fileHeader.append(pe.OPTIONAL_HEADER.MinorLinkerVersion)
		fileHeader.append(pe.FILE_HEADER.NumberOfSections)
		fileHeader.append(pe.FILE_HEADER.NumberOfSymbols)
		fileHeader.append(pe.FILE_HEADER.Characteristics)

		#OPTIONAL_HEADER: 16
		fileHeader.append(pe.OPTIONAL_HEADER.SizeOfCode)
		fileHeader.append(pe.OPTIONAL_HEADER.SizeOfInitializedData)
		fileHeader.append(pe.OPTIONAL_HEADER.SizeOfUninitializedData)
		fileHeader.append(pe.OPTIONAL_HEADER.AddressOfEntryPoint)
		fileHeader.append(pe.OPTIONAL_HEADER.BaseOfCode)
		try:
			fileHeader.append(pe.OPTIONAL_HEADER.BaseOfData)
		except AttributeError:
			fileHeader.append(0)

		fileHeader.append(pe.OPTIONAL_HEADER.ImageBase)
		fileHeader.append(pe.OPTIONAL_HEADER.SectionAlignment)
		fileHeader.append(pe.OPTIONAL_HEADER.FileAlignment)
		fileHeader.append(pe.OPTIONAL_HEADER.MajorOperatingSystemVersion)
		fileHeader.append(pe.OPTIONAL_HEADER.MinorOperatingSystemVersion)
		fileHeader.append(pe.OPTIONAL_HEADER.MajorImageVersion)
		fileHeader.append(pe.OPTIONAL_HEADER.MinorImageVersion)
		fileHeader.append(pe.OPTIONAL_HEADER.MajorSubsystemVersion)
		fileHeader.append(pe.OPTIONAL_HEADER.MinorSubsystemVersion)
		fileHeader.append(pe.OPTIONAL_HEADER.SizeOfImage)
		fileHeader.append(pe.OPTIONAL_HEADER.CheckSum)
		fileHeader.append(pe.OPTIONAL_HEADER.Subsystem)
		fileHeader.append(pe.OPTIONAL_HEADER.DllCharacteristics)
		fileHeader.append(pe.OPTIONAL_HEADER.SizeOfStackReserve)
		fileHeader.append(pe.OPTIONAL_HEADER.SizeOfStackCommit)
		fileHeader.append(pe.OPTIONAL_HEADER.SizeOfHeapReserve)
		fileHeader.append(pe.OPTIONAL_HEADER.SizeOfHeapCommit)
		fileHeader.append(pe.OPTIONAL_HEADER.LoaderFlags)
		fileHeader.append(pe.OPTIONAL_HEADER.NumberOfRvaAndSizes)
		fileHeader.append(len(pe.sections)) #sections number
		
		#get_entropy
		entropy = [x.get_entropy() for x in pe.sections]

		fileHeader.append(sum(entropy) / float(len((entropy)))) #SectionsMeanEntropy
		fileHeader.append(min(entropy)) #SectionsMinEntropy
		fileHeader.append(max(entropy)) #SectionsMaxEntropy

		#Rawsize
		raw_sizes = [x.SizeOfRawData for x in pe.sections]
		fileHeader.append(sum(raw_sizes) / float(len(raw_sizes))) #SectionsMeanRawsize
		fileHeader.append(min(raw_sizes)) #SectionsMinRawsize
		fileHeader.append(max(raw_sizes)) #SectionMaxRawsize

		virtual_sizes = [x.Misc_VirtualSize for x in pe.sections]
		fileHeader.append(sum(virtual_sizes) / float(len(virtual_sizes))) #SectionsMeanVirtualsize
		fileHeader.append(min(virtual_sizes)) #SectionsMinVirtualsize
		fileHeader.append(max(virtual_sizes)) #SectionMaxVirtualsize


		try:
			fileHeader.append(len(pe.DIRECTORY_ENTRY_IMPORT))
			imports = sum([fileDLL.imports for fileDLL in pe.DIRECTORY_ENTRY_IMPORT], [])
			fileHeader.append(len(imports))
			fileHeader.append(len([x for x in imports if x.name is None]))
		except AttributeError:
			fileHeader.append(0)
			fileHeader.append(0)
			fileHeader.append(0)

		try:
			fileHeader.append(len(pe.DIRECTORY_ENTRY_IMPORT.symbols))
		except AttributeError:
			fileHeader.append(0)

		resources = get_resources(pe)
		fileHeader.append(len(resources))

		if(len(resources) > 0):
			entropy = [x[0] for x in resources]
			fileHeader.append(sum(entropy) / float(len(entropy)))
			fileHeader.append(min(entropy))
			fileHeader.append(max(entropy))

			sizes = [X[1] for x in resources]
			fileHeader.append(sum(sizes) / float(len(sizes)))
			fileHeader.append(min(sizes))
			fileHeader.append(max(sizes))
		else:
			fileHeader.append(0)
			fileHeader.append(0)
			fileHeader.append(0)
			fileHeader.append(0)
			fileHeader.append(0)
			fileHeader.append(0)


		#Load Configuration size
		try:
			fileHeader.append(pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.Size)
		except AttributeError:
			fileHeader.append(0)

		#Version Configration size
		try:
			version_info = get_version_info(pe)
			fileHeader.append(len(list(version_info.keys())))
		except AttributeError:
			fileHeader.append(0)



		fileDll = []
		for entryDLL in pe.DIRECTORY_ENTRY_IMPORT:
			fileDll.append(entryDLL.dll.decode("utf-8"))



		typeOfFIle = "Unknown"
		
		for i in fileDll:
			if("Unity" in i):
				typeOfFIle = "Game engine"
			elif ("Crypt" in i):
				typeOfFIle = "Encrypter"
			elif ("OPENGL" in i):
				typeOfFIle = "Graphic engine"



		#PE_Section
		#fileHeader.append(pe.IMAGE_SECTION_HEADER.VirtualAddress)
		#fileHeader.append(pe.IMAGE_SECTION_HEADER.SizeOfRawData)
		#fileHeader.append(pe.IMAGE_SECTION_HEADER.Flags)

		fFile.write(delimiter.join([str(i) for i in fileHeader]))
		fFile.write(delimiter)
		fFile.write(delimiter_for_list.join([str(i) for i in fileDll]))
		fFile.write(delimiter)
		fFile.write(str(typeOfFIle))
		fFile.write(delimiter)
		fFile.write(file_path)
		fFile.write(delimiter)

		fFile.write(str(check_pack_without_yara(file_path)))
		fFile.write(delimiter)

		if("un" in file_path or "VIRUS" in file_path):

			fFile.write("0")
		else:
			fFile.write("1")

		fFile.write("\n")

		
		#print("Phân tích thành công file " + os.path.basename(file_path))

	except pefile.PEFormatError:
		print("File " + os.path.basename((file_path)) +  " không phải định dạng PE")
		fFile.close()
		return 
	except Exception as e:
		print("Phân tích file " + os.path.basename(file_path) + " thất bại do có exception.")
		
		print(e)
		fFile.close()
		return 

	fFile.close()
	return 

'''


if __name__ == '__main__':
	#main()
	print("")

